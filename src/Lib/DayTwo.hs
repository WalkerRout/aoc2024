module Lib.DayTwo (solveDayTwo) where

-- we will reuse these functions, so may as well put them top level...

isSafeReport :: (Ord a, Num a) => [a] -> Bool
isSafeReport xs = areAllAdjacentDiffsValid xs && isIncreasingOrDecreasingOnly xs

areAllAdjacentDiffsValid :: (Ord a, Num a) => [a] -> Bool
-- empty list has valid diffs (none)
areAllAdjacentDiffsValid [] = True
-- a single element also has valid diffs (also none)
areAllAdjacentDiffsValid [_] = True
-- valid diffs for 2+ elements is true only if the two elements are valid and the rest of the elements are valid
areAllAdjacentDiffsValid (x:y:xs) = abs (x - y) >= 1 && abs (x - y) <= 3 && areAllAdjacentDiffsValid (y:xs)

isIncreasingOrDecreasingOnly :: Ord a => [a] -> Bool
isIncreasingOrDecreasingOnly xs = isIncreasingOnly xs || isDecreasingOnly xs
  where
    isIncreasingOnly :: Ord a => [a] -> Bool
    -- an empty list is always increasing
    isIncreasingOnly [] = True
    -- a single element is always increasing
    isIncreasingOnly [_] = True
    -- 2+ elements are always decreasing if the first is > the second and the rest of the elements are all increasing
    isIncreasingOnly (x:y:xs) = x < y && isIncreasingOnly (y:xs)

    isDecreasingOnly :: Ord a => [a] -> Bool
    -- an empty list is always decreasing
    isDecreasingOnly [] = True
    -- a single element is always decreasing
    isDecreasingOnly [_] = True
    -- 2+ elements are always decreasing if the first is > the second and the rest of the elements are all decreasing
    isDecreasingOnly (x:y:xs) = x > y && isDecreasingOnly (y:xs)

solvePartOne :: (Ord a, Num a) => [[a]] -> Int
solvePartOne = length . filter isSafeReport

isSafeDampenedReport :: (Ord a, Num a) => [a] -> Bool
-- this report is safe if it is usually safe, or if any of it's dampened attempts are successful..
isSafeDampenedReport xs = isSafeReport xs || any isSafeReport (removeOneElement xs)

-- (removeOneElement xs) is a list of lists missing a single element each
removeOneElement :: [a] -> [[a]]
-- we cant remove zero elements
removeOneElement [] = []
-- generate a list of all mutations with an element removed
-- we remove the head, adding the tail list to the result
-- we then add the head back to front of all the other new tail-generated lists, since
-- lists generated by removing one from the tail (xs) will still be missing the head (x)...
removeOneElement (x:xs) = xs : map (x:) (removeOneElement xs)

solvePartTwo :: (Ord a, Num a) => [[a]] -> Int
solvePartTwo = length . filter isSafeDampenedReport

solveDayTwo :: IO ()
solveDayTwo = do
  reports <- readFileToList "data/dayTwo.txt"
  print $ solvePartOne reports
  print $ solvePartTwo reports
  print "solved day two..."

readFileToList :: FilePath -> IO [[Int]]
readFileToList filePath = do
  content <- readFile filePath
  return $ parseLevels content

parseLevels :: String -> [[Int]]
parseLevels content = map parseLine (lines content)

parseLine :: String -> [Int]
parseLine line = map read (words line)